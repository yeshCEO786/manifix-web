<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ManifiX</title>
<link rel="icon" href="assets/images/logo.png">
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/supabase.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-tomorrow.css" rel="stylesheet"/>

<!-- Prism.js JS -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-c.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-cpp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-java.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-ruby.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-html.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-css.min.js"></script>
<style>
/* ===== THEME ===== */
:root {
  --bg-image: url('assets/images/profile/placeholder.jpg');
  --panel:#081339;
  --accent1:#1E90FF;
  --accent2:#0B3D91;
  --user:#07245b;
  --bot:#062f45;
  --muted:#AAAAAA;
  --text-light:#fff;
  --text-muted:#CCC;
  --border-radius:12px;
  --font-family:'Inter',sans-serif;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: url('assets/images/profile/placeholder.jpg') no-repeat center center/cover;
  font-family: 'Inter', sans-serif;
  color: #e6eef8;
}

.app { height: 100vh; display: flex; flex-direction: column; }

header {
  display: flex;
  align-items: center;
  padding: 16px;
  background: var(--panel);
  border-bottom: 1px solid #3eb3c7;
  gap: 12px;
}

header img {
  width: 44px;
  height: 44px;
  border-radius: 8px;
  object-fit: cover;
}
#toggleVoiceBtn.off {
  background: #777; /* gray when off */
  color: #111;
}

#toggleVoiceBtn.on {
  background: var(--accent1); /* blue when on */
  color: #111;
}

header h1 {
  margin: 0;
  font-size: 1.2rem;
  color: var(--text-light);
}

main.chat {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  scroll-behavior: smooth;
}

.msg-wrapper { display: flex; width: 100%; position: relative; }
.msg-wrapper.user { justify-content: flex-end; }
.msg-wrapper.bot { justify-content: flex-start; }

.msg-bubble {
  max-width: 80%;
  background: var(--bot);
  border-radius: var(--border-radius);
  padding: 12px 14px;
  line-height: 1.45;
  font-size: 15px;
  position: relative;
  word-break: break-word;
  color: var(--text-light);
  box-shadow:0 6px 20px rgba(39,10,10,0.4);
  animation: fadeIn 0.22s ease;
}

.msg-wrapper.user .msg-bubble {
  background: var(--user);
  color: #fff;
}

.msg-text { white-space: pre-wrap; }

.copy-btn {
  position: absolute;
  top: 2px;
  right: 2px;
  background: rgba(16, 0, 0, 0.55);
  border: 1px solid #222;
  color: #fff;
  padding: 2px 3px;
  font-size: 6px;
  border-radius: 3px;
  cursor: pointer;
  line-height: 1;
  transition: 0.2s, transform 0.1s;
  white-space: nowrap;
}

.copy-btn:hover {
  background: rgba(16, 0, 0, 0.8);
  transform: scale(1.05);
}

.thinking {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: 8px 12px;
  border-radius: var(--border-radius);
}

.dot {
  width: 6px;
  height: 6px;
  background: var(--accent1);
  border-radius: 50%;
  animation: jump 1.1s infinite ease-in-out;
  opacity: 0.9;
}

.dot:nth-child(2) { animation-delay: 0.12s; }
.dot:nth-child(3) { animation-delay: 0.24s; }

@keyframes jump {
  0%,100% { transform: translateY(0); opacity: 0.5; }
  50% { transform: translateY(-6px); opacity: 1; }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(6px); }
  to { opacity: 1; transform: translateY(0); }
}

footer {
  display: flex;
  gap: 10px;
  padding: 14px;
  border-top: 1px solid #888;
  background: var(--panel);
}

textarea {
  flex: 1;
  min-height: 48px;
  padding: 12px 14px;
  border-radius: var(--border-radius);
  border: 1px solid #333;
  background: #060d11;
  color: var(--text-light);
  font-size: 15px;
  outline: none;
  resize: none;
}

button {
  border: 0;
  padding: 10px 12px;
  border-radius: var(--border-radius);
  cursor: pointer;
  background: #777;
  color: var(--text-light);
  font-weight: 600;
}
pre[class*="language-"] {
  background: #1e1e2f;  /* dark background */
  color: #f8f8f2;       /* default text */
  padding: 12px;
  border-radius: 8px;
  overflow-x: auto;
}

#micBtn {
  border: 0;
  padding: 21px 12px;
  border-radius: var(--border-radius);
  cursor: pointer;
  background: var(--accent2); /* Same as toggle button */
  color: #fff;                 /* Text color */
  font-weight: 888;
  transition: 0.2s;
}

#micBtn:hover {
  background: #0a2c70; /* Slightly darker accent for hover */
  transform: scale(1.05);
}

#micBtn.recording {
  background: #ff4b5c;  /* Red when recording */
  color: #fff;
}

button.primary { background: var(--accent1); color: #111010; }
button.togglespeech { background: var(--accent2); }

@media(max-width:640px) {
  .msg-bubble { max-width: 95%; }
  header h1 { font-size: 1rem; }
}
</style>


</head>
<body>
<div class="app">
<header>
<img src="assets/images/logo.png" alt="ManifiX Logo">
<h1>ManifiX</h1>
</header>
<main class="chat" id="chat-container"></main>
<footer>
  <textarea id="user-input" placeholder="Type your messageâ€¦"></textarea>
  <button id="imageBtn" class="primary">Image</button>
  <button id="sendBtn" class="primary">Send</button>
  <button id="micBtn" class="primary">ðŸŽ¤</button>
  <button id="toggleVoiceBtn" class="primary off">ðŸ”Š</button>
</footer>

<script>
/* =========================
   CONFIG â€” fill your keys
   ========================= */
const SUPABASE_URL ="https://sxzltwqufjsjcbsihwcr.supabase.co"; // Optional
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN4emx0d3F1ZmpzamNic2lod2NyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExNDE5MTQsImV4cCI6MjA3NjcxNzkxNH0.c53Wqu8CEhr3vDCs_Z8qKGV4S1BxGhIToo4WtBGE5fk";  // Optional
const OPENROUTER_KEY = "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"; // Optional
const OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions";
const OPENROUTER_IMAGE_URL = "https://openrouter.ai/api/v1/images";
const TTS_ENDPOINT = "https://manifix-backend.onrender.com/api/tts";

/* =========================
   App logic
   ========================= */
document.addEventListener("DOMContentLoaded", () => {
  // DOM refs
  const chatContainer = document.getElementById('chat-container');
  const inputEl = document.getElementById('user-input');
  const sendBtn = document.getElementById('sendBtn');
  const imageBtn = document.getElementById('imageBtn');
  const micBtn = document.getElementById('micBtn');
  const toggleVoiceBtn = document.getElementById('toggleVoiceBtn');
  const signInBtn = document.getElementById('signInBtn');

  // State
  let conversation = []; // {role, content}
  let lastRawReply = "";
  let voiceEnabled = true;
  let supabase = null;
  let recognition = null;
  let recognizing = false;
  let allowAutoSend = false;
  const FORBIDDEN_TEXT_SYMBOLS = /[@#$%^&*]/g; // removed from plain text for display only

  /* ====== Supabase lazy init (optional) ====== */
  async function initSupabaseIfNeeded() {
    if (supabase) return;
    if (!SUPABASE_URL || !SUPABASE_KEY) return;
    if (!window.supabase) {
      try {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/supabase.min.js";
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } catch (e) {
        console.warn('Could not load supabase client', e);
        return;
      }
    }
    try {
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    } catch (e) {
      console.warn('Supabase init failed', e);
      supabase = null;
    }
  }

  async function logToSupabase(role, content) {
    try {
      if (!supabase) return;
      await supabase.from('chat_logs').insert([{ role, content, created_at: new Date().toISOString() }]);
    } catch (e) {
      console.warn('Supabase log failed', e);
    }
  }

  /* ====== UI helpers ====== */
  function createBubble(nodeOrText, who = 'bot', isCode = false) {
    const wrapper = document.createElement('div');
    wrapper.className = 'msg-wrapper ' + (who === 'user' ? 'user' : 'bot');

    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble';

    if (isCode && typeof nodeOrText === 'string') {
      const pre = document.createElement('pre');
      pre.className = 'language-javascript';
      const code = document.createElement('code');
      code.textContent = nodeOrText;
      pre.appendChild(code);
      bubble.appendChild(pre);
    } else if (nodeOrText instanceof Node) {
      bubble.appendChild(nodeOrText);
    } else {
      const span = document.createElement('div');
      span.className = 'msg-text';
      span.textContent = nodeOrText == null ? '' : String(nodeOrText);
      bubble.appendChild(span);
    }

    const copyBtn = document.createElement('div');
    copyBtn.className = 'copy-btn';
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = () => {
      try {
        const txt = (typeof nodeOrText === 'string') ? nodeOrText : (nodeOrText.textContent || '');
        navigator.clipboard.writeText(txt);
      } catch (e) { console.warn('copy failed', e); }
    };
    bubble.appendChild(copyBtn);

    wrapper.appendChild(bubble);
    chatContainer.appendChild(wrapper);
    chatContainer.scrollTop = chatContainer.scrollHeight;

    if (isCode) {
      try {
        const el = wrapper.querySelector('code');
        Prism.highlightElement(el);
      } catch (e) { /* ignore */ }
    }
    return wrapper;
  }

  function addMessage(text, who = 'bot') {
    // Clean plain text for display only (preserve code symbols in code blocks)
    const t = typeof text === 'string' ? text.replace(/\r\n/g, '\n') : (text == null ? '' : String(text));
    createBubble(t, who, false);
  }

  function addCodeMessage(codeText, lang = 'javascript') {
    const pre = document.createElement('pre');
    pre.className = `language-${lang}`;
    const code = document.createElement('code');
    code.className = `language-${lang}`;
    code.textContent = codeText;
    pre.appendChild(code);
    createBubble(pre, 'bot', true);
  }

  function addImageMessage(imageUrl) {
    const wrapper = document.createElement('div');
    wrapper.className = 'msg-wrapper bot';
    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble';
    const img = document.createElement('img');
    img.src = imageUrl;
    img.className = 'gen';
    img.alt = 'Generated image';
    bubble.appendChild(img);
    const copyBtn = document.createElement('div');
    copyBtn.className = 'copy-btn';
    copyBtn.textContent = 'Download';
    copyBtn.onclick = () => {
      const a = document.createElement('a');
      a.href = imageUrl; a.download = 'manifix-image.png';
      document.body.appendChild(a); a.click(); a.remove();
    };
    bubble.appendChild(copyBtn);
    wrapper.appendChild(bubble);
    chatContainer.appendChild(wrapper);
    chatContainer.scrollTop = chatContainer.scrollHeight;
  }

  /* ====== TTS ====== */
  function speakText(text) {
    return new Promise(res => {
      if (!voiceEnabled || !text || !('speechSynthesis' in window)) return res();
      try {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'en-US';
        utter.onend = () => res();
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utter);
      } catch (e) { console.warn('TTS error', e); res(); }
    });
  }

  /* ====== Clean text for plain display (remove limited forbidden symbols) ====== */
  function cleanForDisplay(text) {
    if (typeof text !== 'string') return text;
    return text.replace(FORBIDDEN_TEXT_SYMBOLS, '');
  }

  /* ====== OpenRouter text chat call ====== */
  async function openRouterChat(messages, max_tokens = 1200) {
    if (!OPENROUTER_KEY) throw new Error('OpenRouter key missing');
    const payload = { model: 'gpt-4o-mini', messages, max_tokens };
    const res = await fetch(OPENROUTER_URL, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + OPENROUTER_KEY, 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error('OpenRouter error ' + res.status + ' ' + txt);
    }
    const j = await res.json();
    let reply = j?.choices?.[0]?.message?.content ?? j?.output ?? j?.data?.[0]?.text ?? '';
    if (typeof reply !== 'string') reply = JSON.stringify(reply);
    return reply;
  }

  /* ====== OpenRouter image call (flux) ====== */
  async function openRouterImage(prompt) {
    if (!OPENROUTER_KEY) throw new Error('OpenRouter key missing');
    const payload = { model: "black-forest-labs/flux-pro", input: { prompt, size: "512x512" } };
    let res = await fetch(OPENROUTER_IMAGE_URL, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + OPENROUTER_KEY, 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      // fallback
      const fallback = { model: "black-forest-labs/flux-schnell", input: { prompt, size: "512x512" } };
      res = await fetch(OPENROUTER_IMAGE_URL, {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + OPENROUTER_KEY, 'Content-Type': 'application/json' },
        body: JSON.stringify(fallback)
      });
    }
    const data = await res.json();
    if (data?.data?.[0]?.url) return data.data[0].url;
    if (data?.output?.[0]?.url) return data.output[0].url;
    if (data?.output?.[0]?.b64_json) return "data:image/png;base64," + data.output[0].b64_json;
    if (data?.result?.[0]) return data.result[0];
    return null;
  }

  /* ====== Render AI reply (detect fenced code blocks) ====== */
  function renderReplySegments(fullText) {
    lastRawReply = fullText || '';
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    let lastIndex = 0;
    let m;
    let found = false;
    while ((m = codeBlockRegex.exec(fullText)) !== null) {
      found = true;
      const lang = m[1] || 'javascript';
      const code = m[2];
      const textBefore = fullText.slice(lastIndex, m.index).trim();
      if (textBefore) addMessage(cleanForDisplay(textBefore), 'bot');
      addCodeMessage(code, lang);
      lastIndex = codeBlockRegex.lastIndex;
    }
    const trailing = fullText.slice(lastIndex).trim();
    if (trailing) addMessage(cleanForDisplay(trailing), 'bot');
    if (!found && (!fullText || fullText.trim() === '')) {
      addMessage('', 'bot');
    }
  }

  /* ====== Code generation flow (requests larger token limit) ====== */
  async function generateCodeFlow(prompt) {
    try {
      addMessage(prompt, 'user');
      conversation.push({ role: 'user', content: prompt });
      await initSupabaseIfNeeded();
      await logToSupabase('user', prompt);

      const thinking = createThinking();
      const payloadMessages = [
        { role: 'system', content: 'You are ManifiX. When returning code use fenced code blocks with language tags.' },
        ...conversation.slice(-10),
        { role: 'user', content: prompt }
      ];
      const reply = await openRouterChat(payloadMessages, 1800);
      thinking.remove();
      renderReplySegments(reply);
      conversation.push({ role: 'assistant', content: reply });
      await logToSupabase('bot', reply);
      if (voiceEnabled) await speakText(stripCodeForTTS(reply));
    } catch (e) {
      console.error(e);
      addMessage('Error generating code: ' + (e.message || e), 'bot');
    }
  }

  /* ====== sendMessage (text or image) ====== */
  async function sendMessage(userText, opts = { isImage: false }) {
    if (!userText || !userText.trim()) return;
    addMessage(userText, 'user');
    conversation.push({ role: 'user', content: userText });
    await initSupabaseIfNeeded();
    await logToSupabase('user', userText);

    const thinking = createThinking();
    try {
      if (opts.isImage) {
        const imageUrl = await openRouterImage(userText);
        thinking.remove();
        if (imageUrl) {
          addMessage("Here's your image:", 'bot');
          addImageMessage(imageUrl);
          conversation.push({ role: 'assistant', content: 'Generated image: ' + imageUrl });
          await logToSupabase('bot', 'Generated image: ' + imageUrl);
        } else {
          addMessage("Image generation failed", 'bot');
        }
        return;
      }

      const recent = conversation.slice(-12);
      const messages = [
        { role: 'system', content: 'You are ManifiX â€” a friendly helpful assistant.' },
        ...recent,
        { role: 'user', content: userText }
      ];
      const reply = await openRouterChat(messages, 1200);
      thinking.remove();
      renderReplySegments(reply);
      conversation.push({ role: 'assistant', content: reply });
      await logToSupabase('bot_raw', reply);
      if (voiceEnabled) await speakText(stripCodeForTTS(reply));
    } catch (err) {
      thinking.remove();
      console.error(err);
      addMessage('Error: ' + (err.message || err), 'bot');
    }
  }

  /* ====== small utilities ====== */
  function createThinking() {
    const el = document.createElement('div');
    el.className = 'thinking';
    el.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
    chatContainer.appendChild(el);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return el;
  }

  function stripCodeForTTS(text) {
    return (text || '').replace(/```[\s\S]*?```/g, '').replace(/\n{2,}/g, '\n').trim();
  }

  /* ====== STT init (SpeechRecognition) ====== */
  function initSTT() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) {
      micBtn.style.display = 'none';
      console.warn('STT not supported in this browser');
      return;
    }
    try {
      recognition = new SR();
      recognition.continuous = false;
      recognition.interimResults = true;
      recognition.lang = navigator.language || 'en-US';

      recognition.onstart = () => {
        recognizing = true;
        micBtn.classList.add('recording');
        micBtn.textContent = 'â¹ï¸';
      };

      recognition.onresult = (event) => {
        let interim = '';
        let finalText = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const r = event.results[i];
          const t = r[0].transcript;
          if (r.isFinal) finalText += t + ' ';
          else interim += t + ' ';
        }
        if (finalText.trim()) {
          inputEl.value = cleanForDisplay(finalText.trim());
          if (allowAutoSend) { setTimeout(()=>{ sendMessage(inputEl.value); inputEl.value=''; },80); }
        } else {
          inputEl.value = cleanForDisplay(interim.trim());
        }
      };

      recognition.onerror = (e) => { console.warn('STT error', e); };

      recognition.onend = () => {
        recognizing = false;
        micBtn.classList.remove('recording');
        micBtn.textContent = 'ðŸŽ¤';
      };

      micBtn.addEventListener('click', () => {
        if (!recognition) return alert('Speech recognition not supported');
        if (recognizing) {
          try { recognition.stop(); } catch (e) { /* ignore */ }
        } else {
          try { recognition.start(); } catch (e) { console.warn('STT start failed', e); }
        }
      });

    } catch (e) {
      console.warn('STT init failed', e);
      micBtn.style.display = 'none';
    }
  }

  /* ====== UI event wiring ====== */
  sendBtn.addEventListener('click', () => {
    const t = inputEl.value.trim();
    if (!t) { inputEl.focus(); return; }
    inputEl.value = '';
    if (/generate code/i.test(t)) generateCodeFlow(t);
    else sendMessage(t, { isImage: false });
  });

  imageBtn.addEventListener('click', () => {
    const t = inputEl.value.trim();
    if (!t) { inputEl.focus(); return; }
    inputEl.value = '';
    sendMessage(t, { isImage: true });
  });

  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendBtn.click();
    }
  });

  toggleVoiceBtn.addEventListener('click', () => {
    voiceEnabled = !voiceEnabled;
    toggleVoiceBtn.textContent = voiceEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
  });

  signInBtn && signInBtn.addEventListener('click', async () => {
    await initSupabaseIfNeeded();
    if (!supabase) return alert('Supabase not configured');
    alert('Supabase ready â€” implement real auth flow as needed.');
  });

  /* ====== initial greeting ====== */
  addMessage('Hi ðŸ‘‹ â€” I am ManifiX. How can I help you today?', 'bot');

  /* ====== init STT ====== */
  initSTT();
});
</script>
